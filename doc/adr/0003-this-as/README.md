# ADR 0003: this-as for ClojureScript

| Status | Date | Related |
|--------|------|---------|
| Implemented | 2026-02-10 | CLJS-only |

## Context

ClojureScript provides `this-as`, a macro that binds JavaScript's implicit `this` to a name. It's used for JS interop: object methods, event handlers, constructors. In compiled CLJS, `this-as` expands to `(let [name (js* "this")] ...)` — a compile-time construct.

SCI is an interpreter, not a compiler. There is no compilation step where `js*` can emit JavaScript's `this` keyword. All SCI functions are regular CLJS closures generated by `gen-fn`, which don't naturally expose JS `this` to interpreted code.

## Problem

How do we capture JavaScript's `this` and make it available inside the SCI interpreter?

When an SCI function is called as a JS method (e.g., via `Reflect.apply` in SCI's interop layer), JavaScript sets `this` on the call. But the SCI interpreter runs inside that function as `(types/eval body ctx invoc-array)` — the interpreter has no way to access the JS `this` of its enclosing function.

## Solution

### Architecture

Three layers:

1. **Capture** (`gen-fn` in `fns.cljc`): SCI functions that use `this-as` have `wrap-this-as` store JS `this` directly into the invoc-array at the binding's index via `(js* "this")`.

2. **Macro** (`namespaces.cljc`): The `this-as` SCI macro expands to `(let [name sentinel] body)`, where `sentinel` is a private JS object (`fns/this-as-sentinel`). The sentinel acts as a marker that the analyzer recognizes.

3. **Detection** (`analyzer.cljc`): During analysis, `analyze-let*` checks each binding value with `identical?` against the sentinel. When matched, it records the invoc-array index in a volatile and emits a node that reads from that slot. `expand-fn-args+body` passes this index to `gen-fn` via the FnBody's `:this-as-idx`.

### Implementation details

In `namespaces.cljc`:

```clojure
#?(:cljs (defn this-as [_form _env name & body]
           `(let [~name ~fns/this-as-sentinel]
              ~@body)))
```

In `analyzer.cljc`, `analyze-let*` detects the sentinel value and emits a read-from-slot node:

```clojure
(let [this-as-binding? #?(:cljs (identical? fns/this-as-sentinel binding-value) :clj nil)
      ...
      idx (update-parents ctx cb new-iden)
      v (if this-as-binding?
          (sci.impl.types/->Node (aget ^objects bindings idx) nil)
          (analyze ctx binding-value))
      ...]
  [(update ctx :bindings ...)
   (conj let-nodes v)
   (conj idens new-iden)])
```

The read-from-slot node evaluates to the value already in `bindings[idx]` — which `wrap-this-as` populated with `this` at function entry. The let machinery then stores this value back to the same slot, a harmless no-op.

`expand-fn-args+body` creates a volatile and attaches the index to FnBody:

```clojure
#?@(:cljs [this-as-vol (volatile! false)
           ctx (assoc ctx :this-as this-as-vol)])
...
(cond-> (->FnBody ...)
  #?@(:cljs [@this-as-vol (assoc :this-as-idx @this-as-vol)]))
```

In `fns.cljc`:

```clojure
#?(:cljs (def this-as-sentinel #js {}))

(defmacro wrap-this-as [& body]
  (macros/? :clj `(do ~@body)
            :cljs `(do
                     (when ~'this-as-idx
                       (aset ~'invoc-array ~'this-as-idx (~'js* "this")))
                     ~@body)))
```

`gen-fn` creates the invoc-array first, then calls `wrap-this-as` before evaluating the body. The `this-as-idx` local is bound from the FnBody field passed through `fun`.

### Why this approach

An earlier design used a CLJS-level global mutable as a bridge: `wrap-this-as` would set the global, and the `this-as` macro would read it via a function call. This worked but required cleanup (`try/finally` to clear the reference) and leaked extra vars into the SCI namespace.

The invoc-array approach is simpler: `this` is written directly to the binding's slot, the same storage used for all local variables. No globals, no cleanup, no `try/finally`.

### Why a sentinel object

The sentinel (`#js {}`) is a private JS object defined in `fns.cljc`. Since each `#js {}` is a unique object and the sentinel is not exposed in the SCI namespace, user code cannot produce a value that passes the `identical?` check. This prevents accidental or deliberate triggering of the `this-as` binding behavior.

### Why conditional capture matters

The initial prototype captured `this` unconditionally on every SCI function entry. Benchmarking showed ~19% overhead on `reduce` with 10M iterations — tight loops that call SCI functions millions of times. By detecting `this-as` usage during analysis and only capturing when needed, the overhead drops to zero for functions that don't use `this-as`.

## SCI internals: `loop` and `this-as`

SCI's `loop` expands into an anonymous `fn*` internally. Each such function gets its own `:this-as` volatile during analysis. Since `this-as` is not used inside the loop body (it's in the enclosing function), the loop function's `this-as-idx` is false and `wrap-this-as` is a no-op. The captured `this` value flows through normally via the invoc-array binding.

## Async considerations

SCI's async transformer desugars `await` into `.then` chains. The `.then` callbacks are SCI functions (generated by `gen-fn`), so `wrap-this-as` runs at their entry.

**`this-as` before `await`** — works correctly:

```clojure
(^:async fn []
  (this-as self                          ;; captured eagerly
    (let [result (await some-promise)]
      (.-name self))))                   ;; self is still valid
```

The `let` binding closes over the `.then` callback boundary.

**`this-as` after `await`** — gives `nil` (not the original receiver):

```clojure
(^:async fn []
  (let [result (await some-promise)]
    (this-as self                        ;; self = nil
      (.-name self))))
```

This matches JavaScript `.then` behavior — callbacks don't preserve `this`. Note that native JS `async/await` *does* preserve `this` across `await`, but SCI desugars to `.then`, so the behavior differs. Users should capture `this-as` before any `await`.
