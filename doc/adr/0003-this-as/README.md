# ADR 0003: this-as for ClojureScript

| Status | Date | Related |
|--------|------|---------|
| Implemented | 2026-02-10 | CLJS-only |

## Context

ClojureScript provides `this-as`, a macro that binds JavaScript's implicit `this` to a name. It's used for JS interop: object methods, event handlers, constructors. In compiled CLJS, `this-as` expands to `(let [name (js* "this")] ...)` — a compile-time construct.

SCI is an interpreter, not a compiler. There is no compilation step where `js*` can emit JavaScript's `this` keyword. All SCI functions are regular CLJS closures generated by `gen-fn`, which don't naturally expose JS `this` to interpreted code.

## Problem

How do we capture JavaScript's `this` and make it available inside the SCI interpreter?

When an SCI function is called as a JS method (e.g., via `Reflect.apply` in SCI's interop layer), JavaScript sets `this` on the call. But the SCI interpreter runs inside that function as `(types/eval body ctx invoc-array)` — the interpreter has no way to access the JS `this` of its enclosing function.

## Solution

### Architecture

Three layers:

1. **Capture** (`gen-fn` in `fns.cljc`): SCI functions that use `this-as` wrap their body with `wrap-this-as`, which reads JS `this` via `(js* "this")` and stores it into a CLJS-level mutable (`-js-this`).

2. **Bridge** (`namespaces.cljc`): A function `-js-this` exposed to SCI reads the mutable. The `this-as` SCI macro expands to `(let [name (-js-this)] (try body (finally (-clear-js-this))))`.

3. **Detection** (`analyzer.cljc`): During analysis, a volatile tracks whether `this-as` is used inside a function body. Only functions that use `this-as` pay the capture cost.

### Implementation details

In `fns.cljc`:

```clojure
#?(:cljs (def -js-this nil))

;; No-op on JVM; on CLJS, conditionally captures this
(defmacro wrap-this-as [form]
  (macros/? :clj form
            :cljs `(do
                     (when ~'needs-this
                       (set! -js-this (~'js* "this")))
                     ~form)))
```

Both arity cases in `gen-fn` (0-arity and N-arity) are wrapped with `wrap-this-as`. The `needs-this` local is bound from a `:this-as` flag passed to `fun`.

In `analyzer.cljc`, `expand-fn-args+body` creates a volatile before analyzing the fn body:

```clojure
#?@(:cljs [this-as-vol (volatile! false)
           ctx (assoc ctx :this-as this-as-vol)])
body (return-do ...)
...
(cond-> (->FnBody ...)
  #?@(:cljs [@this-as-vol (assoc :this-as true)]))
```

In `analyze-call`, when a macro is about to be expanded, the symbol is checked:

```clojure
#?@(:cljs [_ (when-let [ta (:this-as ctx)]
               (when (= 'this-as fsym)
                 (vreset! ta true)))])
```

This piggybacks on the existing analysis pass — no separate tree walk needed.

In `namespaces.cljc`:

```clojure
;; Accessor — reads the CLJS mutable from SCI
#?(:cljs (defn -js-this [] fns/-js-this))

;; Cleanup — clears the reference after use
#?(:cljs (defn -clear-js-this [] (set! fns/-js-this nil)))

;; SCI macro — captures this eagerly, cleans up after
#?(:cljs (defn this-as [_form _env name & body]
           `(let [~name (~'-js-this)]
              (try
                ~@body
                (finally
                  (~'-clear-js-this))))))
```

### Why conditional capture matters

The initial implementation captured `this` unconditionally on every SCI function entry. Benchmarking showed ~19% overhead on `reduce` with 10M iterations — tight loops that call SCI functions millions of times. By detecting `this-as` usage during analysis and only capturing when needed, the overhead drops to zero for functions that don't use `this-as`.

### Why a CLJS-level mutable works

CLJS is single-threaded. The mutable `-js-this` is set at function entry (before any user code) and read by `this-as` (which captures it immediately into a `let`). Even if nested SCI function calls overwrite the mutable, the user's `let` binding is already captured.

### Reference cleanup

The `this-as` macro wraps the body in `try/finally` to call `-clear-js-this`, which resets `-js-this` to `nil`. This prevents holding references to potentially large objects after a method call completes.

## Async considerations

SCI's async transformer desugars `await` into `.then` chains. The `.then` callbacks are SCI functions (generated by `gen-fn`), so `wrap-this-as` runs at their entry.

**`this-as` before `await`** — works correctly:

```clojure
(^:async fn []
  (this-as self                          ;; captured eagerly
    (let [result (await some-promise)]
      (.-name self))))                   ;; self is still valid
```

The `let` binding closes over the `.then` callback boundary.

**`this-as` after `await`** — gives `nil` (not the original receiver):

```clojure
(^:async fn []
  (let [result (await some-promise)]
    (this-as self                        ;; self = nil
      (.-name self))))
```

This matches JavaScript `.then` behavior — callbacks don't preserve `this`. Note that native JS `async/await` *does* preserve `this` across `await`, but SCI desugars to `.then`, so the behavior differs. Users should capture `this-as` before any `await`.

## SCI internals: `loop` and `this-as`

SCI's `loop` expands into an anonymous `fn*` internally. Each such function gets its own `:this-as` volatile during analysis. Since `this-as` is not used inside the loop body (it's in the enclosing function), the loop function's `needs-this` is false and `wrap-this-as` is a no-op. The captured `this` value flows through normally via the `let` binding.
