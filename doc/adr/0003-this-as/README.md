# ADR 0003: this-as for ClojureScript

| Status | Date | Related |
|--------|------|---------|
| Implemented | 2026-02-10 | CLJS-only |

## Context

ClojureScript provides `this-as`, a macro that binds JavaScript's implicit `this` to a name. It's used for JS interop: object methods, event handlers, constructors. In compiled CLJS, `this-as` expands to `(let [name (js* "this")] ...)` — a compile-time construct.

SCI is an interpreter, not a compiler. There is no compilation step where `js*` can emit JavaScript's `this` keyword. All SCI functions are regular CLJS closures generated by `gen-fn`, which don't naturally expose JS `this` to interpreted code.

## Problem

How do we capture JavaScript's `this` and make it available inside the SCI interpreter?

When an SCI function is called as a JS method (e.g., via `.apply`, `Reflect.apply`, or property access), JavaScript sets `this` on the call. But the SCI interpreter runs inside that function as `(types/eval body ctx invoc-array)` — the interpreter has no way to access the JS `this` of its enclosing function.

## Prior attempt

Commit `1d945760` added a `wrap-this-as` macro that wrapped `gen-fn` bodies with `cljs.core/this-as`, capturing JS `this` into a CLJS local `__sci_impl_this__`. However:

- Only the 0-arity case in `gen-fn` was wrapped (N-arity was missed)
- No bridge existed to expose the captured value to SCI userland (no SCI macro, no accessor function)
- The namespace entries remained commented out

The attempt was incomplete and was not shipped.

## Solution

### Architecture

Three layers:

1. **Capture** (`gen-fn` in `fns.cljc`): Every SCI function wraps its body with `cljs.core/this-as`, storing JS `this` into a CLJS-level mutable (`-js-this`) before the interpreter runs.

2. **Bridge** (`namespaces.cljc`): A function `-js-this` exposed to SCI reads the mutable. The `this-as` SCI macro expands to `(let [name (-js-this)] body...)`.

3. **Cleanup** (`wrap-this-as`): After the function body returns, `-js-this` is reset to the global `this` to avoid holding references to potentially large objects.

### Implementation details

In `fns.cljc`:

```clojure
;; Store the global this as the default value
#?(:cljs (def -js-global-this (cljs.core/this-as this this)))
#?(:cljs (def -js-this -js-global-this))

;; No-op on JVM, captures this on CLJS
(defmacro wrap-this-as [form]
  (macros/? :clj form
            :cljs `(cljs.core/this-as ~'__sci_this__
                     (set! -js-this ~'__sci_this__)
                     (let [ret# ~form]
                       (set! -js-this -js-global-this)
                       ret#))))
```

Both arity cases in `gen-fn` (0-arity and N-arity) are wrapped with `wrap-this-as`.

In `namespaces.cljc`:

```clojure
;; Accessor function — reads the CLJS mutable from SCI
#?(:cljs (defn -js-this [] fns/-js-this))

;; SCI macro — captures this eagerly into a let binding
#?(:cljs (defn this-as [_form _env name & body]
           `(let [~name (~'-js-this)]
              ~@body)))
```

### Why a CLJS-level mutable works

CLJS is single-threaded. The mutable `-js-this` is set at function entry (before any user code) and read by `this-as` (which captures it immediately into a `let`). Even if nested SCI function calls overwrite the mutable, the user's `let` binding is already captured.

### Reference cleanup

After a function returns, `-js-this` is reset to `-js-global-this` (the global `this` captured at module load time). This prevents holding references to potentially large objects after a method call completes, which could delay GC if the program goes idle.

## Async considerations

SCI's async transformer desugars `await` into `.then` chains. The `.then` callbacks are SCI functions (generated by `gen-fn`), so `wrap-this-as` runs at their entry.

**`this-as` before `await`** — works correctly:

```clojure
(^:async fn []
  (this-as self                          ;; captured eagerly
    (let [result (await some-promise)]
      (.-name self))))                   ;; self is still valid
```

The `let` binding closes over the `.then` callback boundary.

**`this-as` after `await`** — gives `undefined` (not the original receiver):

```clojure
(^:async fn []
  (let [result (await some-promise)]
    (this-as self                        ;; self = undefined
      (.-name self))))
```

This matches JavaScript `.then` behavior — callbacks don't preserve `this`. Note that native JS `async/await` *does* preserve `this` across `await`, but SCI desugars to `.then`, so the behavior differs. Users should capture `this-as` before any `await`.

**No stale values**: Every SCI function entry (including `.then` callbacks) overwrites `-js-this` via `wrap-this-as` before any user code runs. There is no scenario where a stale `this` from a previous call leaks through.

## Performance

Benchmarked with `:optimizations :none` on Node.js. The `wrap-this-as` overhead is one `this` read, two `set!` operations, and one extra `let` per SCI function call.

| Benchmark | Without | With | Overhead |
|---|---|---|---|
| loop/recur 10M | 3175ms | 3171ms | ~0% (recur stays in same fn) |
| reduce 1M | 201ms | 240ms | ~19% |
| recursive 500x1000 | 199ms | 218ms | ~10% |
| varargs 500K | 385ms | 401ms | ~4% |
| multi-arity 500K | 670ms | 691ms | ~3% |
| closures 500K | 422ms | 436ms | ~3% |
| map 1M | 105ms | 98ms | ~noise |

The overhead is most visible in `reduce` and recursion — tight loops that call SCI functions millions of times. The `loop/recur` case is unaffected since `recur` doesn't re-enter the function. Real-world code is unlikely to be dominated by function call overhead.

### Stack depth

The extra `let` frame adds to the JS call stack. This could reduce maximum recursion depth for non-TCO recursive SCI functions. Users should prefer `loop/recur` for deep iteration.
