# ADR 0003: this-as for ClojureScript

| Status | Date | Related |
|--------|------|---------|
| Implemented | 2026-02-10 | CLJS-only |

## Context

ClojureScript provides `this-as`, a macro that binds JavaScript's implicit `this` to a name. It's used for JS interop: object methods, event handlers, constructors. In compiled CLJS, `this-as` expands to `(let [name (js* "this")] ...)` — a compile-time construct.

SCI is an interpreter, not a compiler. There is no compilation step where `js*` can emit JavaScript's `this` keyword. All SCI functions are regular CLJS closures generated by `gen-fn`, which don't naturally expose JS `this` to interpreted code.

## Problem

How do we capture JavaScript's `this` and make it available inside the SCI interpreter?

When an SCI function is called as a JS method (e.g., via `Reflect.apply` in SCI's interop layer), JavaScript sets `this` on the call. But the SCI interpreter runs inside that function as `(types/eval body ctx invoc-array)` — the interpreter has no way to access the JS `this` of its enclosing function.

## Solution

### Architecture

Three layers:

1. **Capture** (`gen-fn` in `fns.cljc`): SCI functions that use `this-as` have `wrap-this-as` store JS `this` directly into the invoc-array at the binding's index via `(js* "this")`.

2. **Macro** (`namespaces.cljc`): The `this-as` SCI macro expands to a `let` with `:sci/this-as` metadata on the binding name. The analyzer detects this metadata and allocates an invoc-array slot without initializing it — `wrap-this-as` fills it at function entry.

3. **Detection** (`analyzer.cljc`): During analysis, `analyze-let*` detects the `:sci/this-as` metadata, records the invoc-array index in a volatile, and skips the let-node so runtime code doesn't overwrite the slot. `expand-fn-args+body` passes this index to `gen-fn` via the FnBody's `:this-as-idx`.

### Implementation details

In `namespaces.cljc`:

```clojure
;; SCI macro — the binding gets metadata that the analyzer detects
#?(:cljs (defn this-as [_form _env name & body]
           `(let [~(with-meta name {:sci/this-as true}) nil]
              ~@body)))
```

In `analyzer.cljc`, `analyze-let*` detects the metadata:

```clojure
(let [this-as-binding? #?(:cljs (:sci/this-as (meta binding-name)) :clj nil)
      v (when-not this-as-binding? (analyze ctx binding-value))
      ...]
  ;; Record the index; skip let-node so runtime doesn't overwrite the slot
  #?(:cljs (when-let [ta (:this-as ctx)]
             (when this-as-binding?
               (vreset! ta idx))))
  [(update ctx :bindings ...)
   (if this-as-binding? let-nodes (conj let-nodes v))
   (if this-as-binding? idens (conj idens new-iden))])
```

`expand-fn-args+body` creates a volatile and attaches the index to FnBody:

```clojure
#?@(:cljs [this-as-vol (volatile! false)
           ctx (assoc ctx :this-as this-as-vol)])
...
(cond-> (->FnBody ...)
  #?@(:cljs [@this-as-vol (assoc :this-as-idx @this-as-vol)]))
```

In `fns.cljc`:

```clojure
;; No-op on JVM; on CLJS, stores this directly into the invoc-array slot
(defmacro wrap-this-as [& body]
  (macros/? :clj `(do ~@body)
            :cljs `(do
                     (when ~'this-as-idx
                       (aset ~'invoc-array ~'this-as-idx (~'js* "this")))
                     ~@body)))
```

`gen-fn` creates the invoc-array first, then calls `wrap-this-as` before evaluating the body. The `this-as-idx` local is bound from the FnBody field passed through `fun`.

### Why this approach

An earlier design used a CLJS-level global mutable (`-js-this`) as a bridge: `wrap-this-as` would set the global, and the `this-as` macro would read it. This worked but required cleanup (`try/finally` to clear the reference) and added an extra indirection.

The invoc-array approach is simpler: `this` is written directly to the binding's slot in the invoc-array, the same storage used for all local variables. No globals, no cleanup, no `try/finally`.

### Why conditional capture matters

The initial prototype captured `this` unconditionally on every SCI function entry. Benchmarking showed ~19% overhead on `reduce` with 10M iterations — tight loops that call SCI functions millions of times. By detecting `this-as` usage during analysis and only capturing when needed, the overhead drops to zero for functions that don't use `this-as`.

### Why skipping the let-node matters

The `this-as` macro expands to `(let [name nil] body)`. Without special handling, the analyzer would create a let-node that stores `nil` into the invoc-array slot at runtime — overwriting the `this` value that `wrap-this-as` stored at function entry. By skipping the let-node (but still allocating the binding and its index), the slot is filled only by `wrap-this-as`.

## SCI internals: `loop` and `this-as`

SCI's `loop` expands into an anonymous `fn*` internally. Each such function gets its own `:this-as` volatile during analysis. Since `this-as` is not used inside the loop body (it's in the enclosing function), the loop function's `this-as-idx` is false and `wrap-this-as` is a no-op. The captured `this` value flows through normally via the invoc-array binding.

## Async considerations

SCI's async transformer desugars `await` into `.then` chains. The `.then` callbacks are SCI functions (generated by `gen-fn`), so `wrap-this-as` runs at their entry.

**`this-as` before `await`** — works correctly:

```clojure
(^:async fn []
  (this-as self                          ;; captured eagerly
    (let [result (await some-promise)]
      (.-name self))))                   ;; self is still valid
```

The `let` binding closes over the `.then` callback boundary.

**`this-as` after `await`** — gives `nil` (not the original receiver):

```clojure
(^:async fn []
  (let [result (await some-promise)]
    (this-as self                        ;; self = nil
      (.-name self))))
```

This matches JavaScript `.then` behavior — callbacks don't preserve `this`. Note that native JS `async/await` *does* preserve `this` across `await`, but SCI desugars to `.then`, so the behavior differs. Users should capture `this-as` before any `await`.
